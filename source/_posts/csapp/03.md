---
title: 03 程序机器级表示
date: 2023-05-29 18:40:30
tags: [c,system,gcc,gdb,汇编]
categories: [course,csapp]
---

## 3.2 机器级编码

汇编程序员可见，但 C 程序员不可见的处理机状态：

- PC Promgram counter `%rip`
- 整数寄存器 integer register file
- 条件码寄存器 condition code registers
- 浮点数寄存器 set of floating-point registers

将 C 语言变成目标代码：

1.  **预处理器**会==扩展源代码==，插入所有用 `#include` 指令的文件，扩展所有用 `#define` 声明指定的宏。
2.  **编译器**基于编程语言的规则、目标机器的指令集和操作系统的惯例，会将源代码==转换为汇编代码==作为输出，给出程序的每一条指令。
3.  **汇编器**将汇编代码==转化为二进制目标代码文件==，它是机器代码的一种形式，包含了所有指令的二进制表示，但是还没有填入全局值的地址。
4.  **链接器**将目标代码文件和实现库函数的==代码合并==，产生最终可执行代码文件。

### 3.2.2 代码实例

```c
// mstore.c
long mult2(long, long);
void multstore(long x, long y,long *dest){
    long t = mult2(x,y);
    *dest = t;
} 
```

#### 编译器

```sh
gcc -Og -S mstore.c
```

-   `-Og` ：是生成机器代码的优化等级，这个表示编译器会==生成符合原始 C 代码整体结构的机器代码==，这是用于调试的级别，便于我们学习观察。其他的 `-O1` 或 `-O2` 会得到更好的程序性能，但是机器代码和源代码的关系就比较难以理解。
-   `-S` ：只生成到汇编代码。

```
multstore:
.LFB0:
	.cfi_startproc
	pushq	%rbx
	.cfi_def_cfa_offset 16
	.cfi_offset 3, -16
	movq	%rdx, %rbx
	call	mult2@PLT
	movq	%rax, (%rbx)
	popq	%rbx
	.cfi_def_cfa_offset 8
	ret
	.cfi_endproc
```

所有以 `.` 开头的行都是*指导汇编器和链接器工作的伪指令*，我们通常可以忽略这些行。对其化简并加上解释，可以得到汇编代码：

```
multstore:
	pushq	%rbx
	movq	%rdx, %rbx
	call	mult2@PLT
	movq	%rax, (%rbx)
	popq	%rbx
	ret
```

#### 汇编器和反汇编器

```sh
gcc -Og -c mstore.c
```

目标代码文件是二进制文件，无法直接查看，所以可以通过**反汇编器**(Disassembler)来将机器代码转化为类似汇编代码的格式

```sh
[lqb@ ~/Course/csapp/03/3.2.2CodeExample]$ objdump -d mstore.o

mstore.o：     文件格式 elf64-x86-64


Disassembly of section .text:

0000000000000000 <multstore>:
   0:   53                      push   %rbx
   1:   48 89 d3                mov    %rdx,%rbx
   4:   e8 00 00 00 00          callq  9 <multstore+0x9>
   9:   48 89 03                mov    %rax,(%rbx)
   c:   5b                      pop    %rbx
   d:   c3                      retq
```

1.  每个指令需要的==字节数不同==，常用的指令和需要较少操作数的指令所需的字节数比较少。
2.  每个指令都有自己对应的编码。
3.  反汇编得到的汇编代码和直接生成的有略微==差异==。

#### 链接器

```c
//main.c
void multstore(long, long, long*);

int main(){
    long d;
    multstore(2, 3, &d);
    printf("%d\n", d);
    return 0;
} 
long mult2(long a, long b){
    long s = a*b;
    return s;
}
```

```sh
gcc -Og -o prog main.c mstore.c
objdump -d prog
```

得到 multistore 函数部分

```sh
0000000000000741 <multstore>:
 741:   53                      push   %rbx
 742:   48 89 d3                mov    %rdx,%rbx
 745:   e8 ef ff ff ff          callq  739 <mult2>
 74a:   48 89 03                mov    %rax,(%rbx)
 74d:   5b                      pop    %rbx
 74e:   c3                      retq   
 74f:   90                      nop
```

可以发现和汇编器生成的汇编代码有所**区别**：

1. 反汇编代码省略了很多指令的后缀 `q` 
2. 链接器将代码移到了==新的地址范围==内。
3. 第 4 行中，链接器==补充了调用函数 `mult2` 需要使用的地址==。
4. 多了两行 `nop` ，可以使得函数代码变成 16 字节，更好放置下一个代码。

### 总结

```sh
gcc -Og -S mstore.c #生成汇编代码
gcc -Og -c mstore.c #生成目标代码
objdump -d mstore.o #将目标代码反汇编为类汇编代码
gcc -Og -o prog main.c mstore.c #链接
```

## 3.3 数据格式

![Pasted image 20230401153408.png](https://s2.loli.net/2023/05/29/DQteOBniRJEWT9u.png)

## 3.4 访问信息

x86-64 寄存器

<a href="https://smms.app/image/PJfm8AB1Hd7eDnC" target="_blank"><img src="https://s2.loli.net/2023/05/30/PJfm8AB1Hd7eDnC.png" ></a>

- 有一个寄存器是 `%rsp` 只能用于作为栈 (顶)指针
- 寄存器分为**调用者保存**寄存器和**被调用者保存**寄存器：


### 3.4.1 指令的操作数

指令分为操作码和操作数：

<a href="https://smms.app/image/NHyAPrOfxlMmVLv" target="_blank"><img src="https://s2.loli.net/2023/05/29/NHyAPrOfxlMmVLv.png" ></a>

操作数有三种级别类型 (ATT 格式)：

1. 立即数 $\$x$
2. 寄存器 $r_a$
3. 内存引用 $()$

所有操作数可以概括为一种寻址模式：

$$Imm(r_b,r_i,s)$$
$$M=Imm+R[r_b]+R[r_i] s$$
- $Imm$ 立即数
- $r_b$ 基址寄存器
- $r_i$ 变址寄存器
- $s$ 比例因子必须为 1,2,4,8 即==数组数据类型的大小==

<a href="https://smms.app/image/BnytMxFDpmP7wOk" target="_blank"><img src="https://s2.loli.net/2023/05/30/BnytMxFDpmP7wOk.png" ></a>

> x86-64 是**64位**系统，内存引用使用的寄存器==必须是8字节寄存器==，不可能是 `(%eax)` 这种情况

### 3.4.2 数据传送指令

#### 源操作数和目的操作数的相关要求

<a href="https://smms.app/image/dg5K32QwykGEzi6" target="_blank"><img src="https://s2.loli.net/2023/05/29/dg5K32QwykGEzi6.png" alt="Pasted image 20230401171914.png"></a>
一般情况：

- 源操作数为立即数、寄存器、内存
- 目的操作数为寄存器、内存

特殊情况：

- 目的操作数和源操作数==不能都是==内存地址
- 如果要完成内存到内存的数据传送需要两条 `mov` 指令

#### 按照数据传送指令的大小关系进行分类


**源和目的的大小相同**

<a href="https://smms.app/image/GlYFVWSmaO2dBTf" target="_blank"><img src="https://s2.loli.net/2023/05/30/GlYFVWSmaO2dBTf.png" ></a>

一般情况:

- 根据 `mov` 末尾的大小复制对应大小的数据
- `movq`源操作数是立即数时，只能用==32位补码==表示，然后进行**符号扩展**并传送到目的位置。
- 源操作数和目的操作数==大小必须匹配==

特殊情况:

- `movl` 以寄存器为目的时，会将寄存器的高位4字节置0。
- `movabsq`能够**以任意64位立即数**作为源操作数，并且**只能以寄存器作为目的**

**源和目的的大小不同**

<a href="https://smms.app/image/srQOyqTR3o9HavI" target="_blank"><img src="https://s2.loli.net/2023/05/30/srQOyqTR3o9HavI.png" ></a>

一般情况:

- `movs` 和 `movz` 类指令分别进行符号扩展和零扩展
- 将较**小**空间的数值传送到较**大**空间的位置上
- 然后分别进行**符号扩展和零扩展**

特殊情况:

- 没有 `movzlq` 这条指令，因为 `movl` 本身就会完成零扩展 (高四字节置 0)
- `cltq`没有操作数，等价于`movslq %eax,%rax`。

#### 总结

- 数据传送指令源操作数和目的操作数==不能都是内存引用==
- 源操作数的目的操作数大小相同时，默认进行==符号扩展==，但 `movl` 会默认将高四位置 0 ，变成零扩展
- 源操作数的目的操作数大小不同时，有 `movs` 和 `movz` 类指令可以分别实现符号扩展和零扩展，不存在 `movzlq` 指令，因为 `movl` 可以实现相同的功能 

### 3.4.3 数据传送实例

```c
Int main ()
{
	Long a = 4;
	Long b = exchange (&a, 3);
	Printf ("a = %ld, b = %ld\n", a, b);
	Return 0;
}
```

```c
Long exchange (long *xp, long y){
    Long x = *xp;
    *xp = y;
    Return x;
}
```

```text
 Exchange:
    Movq (%rdi),%rax
    Movq %rsi, (%rdi)
    Ret
```

- 根据惯例 `%rdi,%rsi` 分别用来存储**第 1、2 个**参数
- `%rax` 保存返回值

### 3.4.4 push 和 pop

按照惯例
- ==栈底在上，栈顶在下==
- 上方为高地址，下方为低地址
- 压栈时栈指针做**减**法

<a href="https://smms.app/image/uZo7UnMJvPpCGQK" target="_blank"><img src="https://s2.loli.net/2023/05/30/uZo7UnMJvPpCGQK.png" ></a>

压栈：先减栈指针，再写入数据
弹栈：先读取数据，再加栈指针

## 3.5 算数和逻辑运算

### 3.5.1 加载有效地址

`leaq Src, Dst`

- `Src` 是内存引用的形式，但实质上==没有引用内存==的数据，而是将表示的**有效地址**写入 `Dst`
- 实际上，编译器有一些 `leaq` 的**灵活用法**，使用起来根本==与有效地址计算无关==
- 要求==目的操作数必须是寄存器==

`leaq` 用于实现快速乘法运算的灵活用法:

```c
Long m 12 (long x)
{
    Return x * 12;
}
```

可以只用 leaq 指令完成快速运算

```text
Leaq (%rdi, %rdi, 2), %rax # t <- x+x*2
Salq $2, %rax              # return t << 2
```

### 3.5.2 一元操作和二元操作

<a href="https://smms.app/image/tEfQ6XjOK7weUgy" target="_blank"><img src="https://s2.loli.net/2023/05/29/tEfQ6XjOK7weUgy.png" alt="Pasted image 20230410220503.png"></a>
<a href="https://smms.app/image/yUWnXij8rJLGoVh" target="_blank"><img src="https://s2.loli.net/2023/05/29/yUWnXij8rJLGoVh.png" alt="Pasted image 20230410220439.png"></a>

### 3.5.3 移位操作

<a href="https://smms.app/image/tUTbBG5VsAWjDzi" target="_blank"><img src="https://s2.loli.net/2023/05/29/tUTbBG5VsAWjDzi.png" alt="Pasted image 20230411012100.png"></a>

- K 可以是**立即数或寄存器**，寄存器==必须为 `%cl` ==
- 使用 `%cl` 对 $w$ 位长的数据进行移位操作，移位量实际上是由 `%cl` 的**低 $log_2 w$ 决定的** 

### 3.54 算数运算实例

```c
Long arith (long x, long y, long z)  
{  
	Long t 1 = x^y;  
	Long t 2 = z*48;  
	Long t 3 = t 1 & 0 x 0 F 0 F 0 F 0 F;  
	Long t 4 = t 2 - t 3;  
	Return t 4;  
}
```

```text
Xorq	%rsi, %rdi
Leaq	(%rdx,%rdx, 2), %rax
Salq	$4, %rax
Andl	$252645135, %edi
Subq	%rdi, %rax
Ret
```

注意 `long t 2 = z*48` 被拆分成两条指令 `leaq (%rdx,%rdx, 2), %rax  salq $4, %rax` ,相当于乘 3 再乘 16。==不直接使用乘法指令是因为乘法指令的执行需要更多的时间==

### 3.5.5 特殊的算数操作

<a href="https://smms.app/image/vEgrTQHshV1p2Fz" target="_blank"><img src="https://s2.loli.net/2023/05/30/vEgrTQHshV1p2Fz.png" ></a>

`imulq` 和 `mulq` 

- 两条指令只有一个操作数，但是==隐含寄存器为 `%rax` ==
- 乘积的结果为 128 位，分别==保存在寄存器 `%rdx` (高 64 位) 和 `%rax` (低 64 位)==

```c
Void store_uprod (unint 128_t *dest, unint_64 x, unint_64 y)
{
	*dest = x*(unint 128_t) y;
}
```
```text
Movq %rsi,%rax
Mulq %rdx
Movq %rax, (%rdi)
Movq %rdx,8 (%rdi)
```

- `mulq %rdx` 实际将 %rdx 和 %rax 相乘
- 计算机采用小端法，将低 64 位存储在 (%rdi) 高 64 位存储在 8 (%rdi)

`idivq` 和 `divq`

- 实现 128 位除法时，== `%rdx` `%rax` 分别存储被除数的高 64 位和低 64 位==，除数由操作数给出，运算结果， `%rax` 存储商， `%rdx` 存储余数
- 对 64 位除法应用， `%rax` 存储被除数，同时要保证 `%rdx` 为 0 (无符号除法)或 `%rax` 的符号位 (有符号除法)，这个过程是可以直接用指令 `cqto` 完成

### 总结

- `leaq` 目的操作数必须是寄存器
- 移位操作使用的寄存器必须为 `%cl`
- 乘法操作和除法操作隐含寄存器 `%rax` 作为乘数或被除数

## 3.6 控制

### 3.6.1 条件码

#### 条件码寄存器

<a href="https://smms.app/image/PJj26HWIbC4uTMn" target="_blank"><img src="https://s2.loli.net/2023/05/30/PJj26HWIbC4uTMn.png" ></a>

- ZF：零标志，最近的操作得到的结果是否为 0。
- 无符号数：
	- CF：进位标志，最近的操作使得==最高位产生进位==。可用来检查无符号数是否存在溢出。
- 补码：
	- SF：符号标志，最近的操作得到的结果为负数。
	- OF：溢出标志，最近的操作导致==补码溢出==（可以通过符号位进一步判断是正溢出还是负溢出）

#### 算数运算和条件码

<a href="https://smms.app/image/pucMQdkPZegIjsb" target="_blank"><img src="https://s2.loli.net/2023/05/30/pucMQdkPZegIjsb.png" ></a>

当执行上图的算数运算指令时，会修改条件寄存器

> Leaq 不会修改条件码

#### CMP 和 TEST

- CMP 和 TEST 两类指令类似都是==只设置条件码寄存器而不改变其他寄存器==
- CMP 和 SUB 指令的行为一致
- TEST 和 AND 指令行为一致
	- `test %rax,%rax` 检查 %rax 是正数、负数还是 0

### 3.6.2 访问条件码

`set` 类指令可以根据条件码的组合将==一个字节设置为 0 或 1==

<a href="https://smms.app/image/x1Vmbf2qJsvn5CA" target="_blank"><img src="https://s2.loli.net/2023/05/30/x1Vmbf2qJsvn5CA.png" ></a>

有符号数一般判断*零标志位、溢出标志位和符号标志位*：

<a href="https://smms.app/image/Kd1uBGo6bgLPQ9r" target="_blank"><img src="https://s2.loli.net/2023/05/30/Kd1uBGo6bgLPQ9r.png" ></a>

无符号数一般判断*零标志位和进位位*：

<a href="https://smms.app/image/fbq52JGHSnzor7p" target="_blank"><img src="https://s2.loli.net/2023/05/30/fbq52JGHSnzor7p.png" ></a>

### 3.6.3 跳转指令

`jmp` 类指令根据条件码的组合跳转至程序的某个地方

跳转指令分为两类:

- 直接跳转：在汇编中以**标号**表示跳转目标 `jmp .L 1`
- 间接跳转：**\*** 后给出**操作数**表示跳转目标
	- `jmp *%rax` 寄存器的值为跳转目标
	- `jmp *(%rax)` 内存引用为跳转目标

<a href="https://smms.app/image/WewXKFELMR6hiSb" target="_blank"><img src="https://s2.loli.net/2023/05/30/WewXKFELMR6hiSb.png" ></a>

> 条件跳转==只能是直接跳转==，直接在代码中给出而不是由操作数提供的。

### 3.6.4 跳转指令编码

目标地址的编码分为两类:

- **相对寻址**：最常用
	- ==目的地址-跳转指令的下一条指令的地址==
	- 长度可以是**1、2、4**字节
- **绝对寻址**
	- **4** 字节直接标明目的地址

### 3.6.5 条件控制实例

```c
Long absdiff (long x, long y)
{
    Long result;
    If (x > y)
        Result = x-y;
    Else
        Result = y-x;
    Return result;
}
```

对应汇编代码 (未优化)为：

```c
Absdiff:
    Cmpq    %rsi, %rdi
    Jle     .L 4
    Movq    %rdi, %rax
    Subq    %rsi, %rax
    Ret
.L 4:    # x <= y
    Movq    %rsi, %rax
    Subq    %rdi, %rax
    Ret
```

如果将汇编代码改写成 C 语言代码为：

```c
Long absdiff_goto (long x, long y)
{
    Long result;
    Int ntest = x <= y;
    If (ntest) goto Else;
    Result = x-y;
    Return result;
Else:
    Result = y-x;
    Return result;
}
```

也就是说对应 `if-else` 的 C 语言代码，汇编实现会以以下形式实现：

```c
	T = test-expr;
	If (! T)
		Goto false;
	Then-statement
	Goto done:
Else:
	Else-statment
Done:
```

`if` 语句翻译成 `goto` 有另一种实现：

```c
	T = test-expr;
	If (t)
		Goto true;
	Else-statement
	Goto done:
True:
	Then-statment
Done:
```

但是原来的方法更好，因为他对通常情况下**有 if 但没有 else**的支持更好

```c
	T = test-expr;
	If (! T)
		Goto done;
	Then-statement
	Goto done:
Done:
```

### 3.6.6 条件传送

`cmov` 类指令根据条件码的组合选择是否传送数据

<a href="https://smms.app/image/EcSWlayRn7vgTtG" target="_blank"><img src="https://s2.loli.net/2023/05/30/EcSWlayRn7vgTtG.png" ></a>

```c
Long absdiff (long x, long y){
  If (x<y)
    Return y-x;
  Else:
    Return x-y;
}
```

编译后：

```text
Absdiff:
  Movq %rsi, %rax
  Subq %rdi, %rax  //y-x
  Movq %rdi, %rdx
  Subq %rsi, %rdx  //x-y
  Cmpq %rsi, %rdi
  Cmovge %rdx, %rax
  Ret 
```

改写成 C 代码为：

```c
Long cmovdiff (long x, long y){
	Long rval = y-x;
	Long lval = x-y;
	Long ntest = x>=y;
	If (ntest) rval = lval;
	Return rval;
}
```

- 可以发现，编译器==既计算了 y-x 也计算了 x-y==
- 使用条件传送方式的汇编代码效率更高，这是因为现代处理器通过流水线方式获得高性能，而**条件分支**方式需要采用**分支预测**判断跳转是否执行，如果预测失败会导致程序性能严重下降
- 但是不是所有 `if` 语句都能用条件传送来编译

### 3.6.7 循环

#### Do while

```c
// Do While 的 C 语言代码
Long pcount_do (unsigned long x)
{
    Long result = 0;
    Do {
        Result += x & 0 x 1;
        X >>= 1;
    } while (x);
    Return result;
}

// Goto 版本
Long pcount_goto (unsigned long x)
{
    Long result = 0;
Loop:
    Result += x & 0 x 1;
    X >>= 1;
    If (x) goto loop;
    Return result;
}
```

#### While

```c
// C While version
While (Test)
	Body

// Goto Jump to middle Version
	Goto test;
Loop:
	Body
Test:
	If (Test)
		Goto loop;
Done:

// Goto graded-do Version
If (! Test)
	Goto done;
Loop:
	Body-statement
	If (Test) goto loop;
Done:
```

#### For

```c
// For
For (Init; Test; Update)
	Body
	
// While Version
Init;
While (Test) {
	Body
	Update;
}
```

- `for` 循环实际上可以看成 `init-expr` + `for` 循环的过程

### 3.6.8 switch

- `switch`语句可以根据一个整数索引数值进行多重分支。通常使用**跳转表**（Jump Table）数据结构使得实现更加高效，它是一个数组，每个元素是对应的代码块起始地址，根据整数索引得到对应的代码地址后，就可以直接跳转到对应的代码块。
- 相比很长的`if-else`语句的优势在于：执行`switch`语句的时间**与分支数目无关**。比如有很长的分支语句，如果用`if-else`实现，则可能需要经过若干个`if-else`才能跳转到目的代码块，而使用`switch`能根据跳转表直接获得代码块地址
- GCC 根据 `swith` 的情况来翻译：当**数量多**并且**值的跨度小**时，就会使用跳转表

```c
Long switch_eg (long x, long y, long z){
	Long w = 1;
	Switch (x) {
		Case 1:
			W = y*z;
			Break;
		Case 2:
			W = y/z;
			// fall through
		Case 3:
			W += z;
			Break;
		Case 5:
		Case 6:
			W -= z;
			Break;
		Default:
			W = 2;
	}
	Return w;
}
```

```text
Switch_eg:
    Movq    %rdx, %rcx
    Cmpq    $6, %rdi    # x:6
    Ja      .L 8
    Jmp     *. L 4 (, %rdi, 8)

#跳转表
.section    .rodata
    .align 8
.L 4:
    .quad   .L 8 # x = 0
    .quad   .L 3 # x = 1
    .quad   .L 5 # x = 2
    .quad   .L 9 # x = 3
    .quad   .L 8 # x = 4
    .quad   .L 7 # x = 5
    .quad   .L 7 # x = 6
```

```ad-note
- Case 的范围是 1~6
- 汇编代码**先判断是否超过 6**，如果超过则执行 defalut
- 没超过 6**再根据跳转表进行跳转**
```

### 总结

- 执行算数运算、 `cmp` 和 `test` 指令会设置条件码
- 使用条件码有三种方式：
	- `set` 类指令
	- `jmp` 类指令
	- `cmov` 类指令
- `jmp` 类指令可以实现条件控制 `if-else` ，部分情况下使用 `cmov` 类指令代替实现具有更佳的性能